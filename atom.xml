<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://haihaihai2015.github.io</id>
    <title>海的博客</title>
    <updated>2021-10-28T12:15:45.668Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://haihaihai2015.github.io"/>
    <link rel="self" href="https://haihaihai2015.github.io/atom.xml"/>
    <subtitle>你是因为什么事进来的？</subtitle>
    <logo>https://haihaihai2015.github.io/images/avatar.png</logo>
    <icon>https://haihaihai2015.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 海的博客</rights>
    <entry>
        <title type="html"><![CDATA[电影]]></title>
        <id>https://haihaihai2015.github.io/post/dian-ying/</id>
        <link href="https://haihaihai2015.github.io/post/dian-ying/">
        </link>
        <updated>2021-10-28T12:14:32.000Z</updated>
        <content type="html"><![CDATA[ <script type="text/javascript" src="https://www.douban.com/service/badge/188076555/?selection=latest&amp;picsize=small&amp;show=collection&amp;n=8&amp;columns=2"></script>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[工作流、业务流、审批流的区别]]></title>
        <id>https://haihaihai2015.github.io/post/gong-zuo-liu-ye-wu-liu-shen-pi-liu-de-qu-bie/</id>
        <link href="https://haihaihai2015.github.io/post/gong-zuo-liu-ye-wu-liu-shen-pi-liu-de-qu-bie/">
        </link>
        <updated>2021-10-28T06:53:55.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>一直对这三种流的理解不够清晰，今天看到一个很妙的比喻</p>
</blockquote>
<h2 id="工作流火车轨道"><strong>工作流：火车轨道</strong></h2>
<p>工作流代表的是一种方法或者工具。</p>
<h2 id="业务流整个火车运营体系"><strong>业务流：整个火车运营体系</strong></h2>
<p><strong>表单</strong>就好比<strong>火车</strong>，将各种数据传输出去，<strong>业务流</strong>可以很长，传输路线中有很多的站点，<strong>站点就是任务流程节点</strong>，在不同的节点需要对数据进行审查、编辑、<strong>批准</strong>、增加新数据。</p>
<h2 id="审批流信号灯"><strong>审批流：信号灯</strong></h2>
<p>随着整个火车运营体系不断壮大，火车也不止一辆，线路不止一条，为了规避种种不可控的风险，设置了 <strong>信号灯</strong>，用来控制<strong>业务流</strong>，降低风险。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Navicat常用快捷键/实用技巧]]></title>
        <id>https://haihaihai2015.github.io/post/navicat-chang-yong-kuai-jie-jian-shi-yong-ji-qiao/</id>
        <link href="https://haihaihai2015.github.io/post/navicat-chang-yong-kuai-jie-jian-shi-yong-ji-qiao/">
        </link>
        <updated>2021-10-27T02:23:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-navicat快捷键">1. Navicat快捷键</h1>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ctrl+F</td>
<td style="text-align:center">搜索本页数据</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Q</td>
<td style="text-align:center">打开查询窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+/</td>
<td style="text-align:center">注释sql语句</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift +/</td>
<td style="text-align:center">解除注释</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+R</td>
<td style="text-align:center">运行查询窗口的sql语句</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+Shift+R</td>
<td style="text-align:center">只运行选中的sql语句</td>
</tr>
<tr>
<td style="text-align:center">F6</td>
<td style="text-align:center">打开一个mysql命令行窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+L</td>
<td style="text-align:center">删除一行</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+N</td>
<td style="text-align:center">打开一个新的查询窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+W</td>
<td style="text-align:center">关闭一个查询窗口</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+D</td>
<td style="text-align:center">表的数据显示显示页面切换到表的结构设计页面，但是在查询页面写sql时是复制当前行</td>
</tr>
</tbody>
</table>
<h1 id="2-实用技巧">2. 实用技巧</h1>
<h2 id="21-navicat查询字段名">2.1 Navicat查询字段名</h2>
<p>SELECT * FROM 表名.COLUMNS WHERE COLUMN_NAME='字段名';</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IntelliJ IDEA 2021 常用快捷键/实用技巧]]></title>
        <id>https://haihaihai2015.github.io/post/intellij-idea-2021-chang-yong-kuai-jie-jian-shi-yong-ji-qiao/</id>
        <link href="https://haihaihai2015.github.io/post/intellij-idea-2021-chang-yong-kuai-jie-jian-shi-yong-ji-qiao/">
        </link>
        <updated>2021-10-26T03:20:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1常用快捷键">1.常用快捷键</h1>
<h2 id="11-查找替换搜索">1.1 查找替换搜索</h2>
<table>
<thead>
<tr>
<th style="text-align:center">查找替换搜索</th>
<th style="text-align:center">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl + F</td>
<td style="text-align:center">当前文件中文本查找</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + R</td>
<td style="text-align:center">当前文件中文本替换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + shift + F</td>
<td style="text-align:center">根据输入内容查找整个项目 或 指定目录内文件</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + shift + R</td>
<td style="text-align:center">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件</td>
</tr>
<tr>
<td style="text-align:center">shift + shift</td>
<td style="text-align:center">快速搜索</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="12-代码编写">1.2 代码编写</h2>
<table>
<thead>
<tr>
<th style="text-align:center">代码编写</th>
<th style="text-align:center">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl + W</td>
<td style="text-align:center">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + D</td>
<td style="text-align:center">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + /</td>
<td style="text-align:center">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + shift + enter</td>
<td style="text-align:center">代码自动补全，自动结束代码，行末自动添加分号，或者在输入if等语法后自动添加花括号</td>
</tr>
<tr>
<td style="text-align:center">Alt + Enter	IntelliJ IDEA</td>
<td style="text-align:center">根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 ，例如根据当前行代码创建还未定义的函数</td>
</tr>
<tr>
<td style="text-align:center">Alt + Shift + 鼠标点击</td>
<td style="text-align:center">多行光标</td>
</tr>
<tr>
<td style="text-align:center">shift + enter</td>
<td style="text-align:center">行中回车，开辟下一行</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Alt + L</td>
<td style="text-align:center">格式化代码，可以对当前文件和整个包目录使用</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Alt + O</td>
<td style="text-align:center">优化导入的类，可以对当前文件和整个包目录使用</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Alt + 左方向键</td>
<td style="text-align:center">退回到上一个操作的地方</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Alt + 右方向键</td>
<td style="text-align:center">前进到上一个操作的地方</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift + J</td>
<td style="text-align:center">自动将下一行合并到当前行末尾</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift + Z</td>
<td style="text-align:center">取消撤销</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift + W</td>
<td style="text-align:center">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift + N</td>
<td style="text-align:center">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift + U</td>
<td style="text-align:center">对选中的代码进行大 / 小写轮流转换</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift + P</td>
<td style="text-align:center">代码智能提示</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + P</td>
<td style="text-align:center">方法参数提示显示</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift + /</td>
<td style="text-align:center">代码块注释</td>
</tr>
<tr>
<td style="text-align:center">F2</td>
<td style="text-align:center">跳转到下一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td style="text-align:center">F11</td>
<td style="text-align:center">添加书签</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + shift + L</td>
<td style="text-align:center">格式化代码</td>
</tr>
<tr>
<td style="text-align:center">shift + F6</td>
<td style="text-align:center">快速修改方法签名</td>
</tr>
<tr>
<td style="text-align:center">ESC</td>
<td style="text-align:center">从工具窗口进入代码文件窗口</td>
</tr>
<tr>
<td style="text-align:center">Home</td>
<td style="text-align:center">快速移动光标到行首</td>
</tr>
<tr>
<td style="text-align:center">End</td>
<td style="text-align:center">快速移动光标到行尾</td>
</tr>
<tr>
<td style="text-align:center">Alt + Shift + 前方向键</td>
<td style="text-align:center">移动光标所在行向上移动</td>
</tr>
<tr>
<td style="text-align:center">Alt + Shift + 后方向键</td>
<td style="text-align:center">移动光标所在行向下移动</td>
</tr>
<tr>
<td style="text-align:center">Shift + Tab</td>
<td style="text-align:center">取消缩进</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + alt + 左右</td>
<td style="text-align:center">跳转历史光标所在处</td>
</tr>
<tr>
<td style="text-align:center">alt + 左右</td>
<td style="text-align:center">切换子tab</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Y</td>
<td style="text-align:center">删除整行</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + B</td>
<td style="text-align:center">进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Z、Ctrl + shift + Z</td>
<td style="text-align:center">撤销与取消撤销</td>
</tr>
<tr>
<td style="text-align:center">alt + insert</td>
<td style="text-align:center">代码自动生成，如对象的set / get方法，构造函数，toString()等</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + alt + T</td>
<td style="text-align:center">代码包裹功能，快速将选中的代码块包裹到选择的语句块中（if，while等）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="13-调试">1.3 调试</h2>
<table>
<thead>
<tr>
<th style="text-align:center">调试</th>
<th style="text-align:center">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Shift + F10</td>
<td style="text-align:center">等效于点击工具栏的 Run 按钮，程序为上次运行的程序</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + Shift + F10</td>
<td style="text-align:center">在当前程序，Run 按钮</td>
</tr>
<tr>
<td style="text-align:center">Shift + F7</td>
<td style="text-align:center">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td style="text-align:center">Shift + F8</td>
<td style="text-align:center">在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td>
</tr>
<tr>
<td style="text-align:center">Shift + F9</td>
<td style="text-align:center">等效于点击工具栏的 Debug 按钮</td>
</tr>
<tr>
<td style="text-align:center">F7</td>
<td style="text-align:center">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td style="text-align:center">F8</td>
<td style="text-align:center">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td style="text-align:center">F9</td>
<td style="text-align:center">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td style="text-align:center">F12</td>
<td style="text-align:center">回到前一个工具窗口，比如跳转到run界面</td>
</tr>
<tr>
<td style="text-align:center">ESC</td>
<td style="text-align:center">从工具窗口进入代码文件窗口</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="14-其他">1.4 其他</h2>
<table>
<thead>
<tr>
<th style="text-align:center">其他</th>
<th style="text-align:center">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl + D</td>
<td style="text-align:center">show Diff</td>
</tr>
<tr>
<td style="text-align:center">Alt + 7</td>
<td style="text-align:center">显示structure窗口，方便查看类中的方法结构（推荐）</td>
</tr>
</tbody>
</table>
<h1 id="2实用技巧">2.实用技巧</h1>
<h2 id="21-实时代码模板">2.1 实时代码模板</h2>
<table>
<thead>
<tr>
<th style="text-align:center">输入</th>
<th style="text-align:center">显示</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">private static Logger logger = LoggerFactory.getLogger($CLASS_NAME$.class);</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="22-inject-language">2.2 inject language</h2>
<p>如果你使用IDEA在编写JSON字符串的时候，然后要一个一个\去转义双引号的话，就实在太不应该了，又烦又容易出错。在IDEA可以使用Inject language帮我们自动转义双引号。<br>
<img src="https://haihaihai2015.github.io/post-images/1635218928685.png" alt="" loading="lazy"><br>
先将焦点定位到双引号里面，使用alt+enter快捷键弹出inject language视图，并选中 Inject language or reference。<br>
<img src="https://haihaihai2015.github.io/post-images/1635218936022.png" alt="" loading="lazy"><br>
选择后,切记，要直接按下enter回车键，才能弹出inject language列表。在列表中选择 json组件。<br>
<img src="https://haihaihai2015.github.io/post-images/1635218941703.png" alt="" loading="lazy"><br>
选择完后。鼠标焦点自动会定位在双引号里面，这个时候你再次使用alt+enter就可以看到<br>
<img src="https://haihaihai2015.github.io/post-images/1635218954601.png" alt="" loading="lazy"><br>
选中Edit JSON Fragment并回车，就可以看到编辑JSON文件的视图了。<br>
<img src="https://haihaihai2015.github.io/post-images/1635218957113.png" alt="" loading="lazy"><br>
可以看到IDEA确实帮我们自动转义双引号了。如果要退出编辑JSON信息的视图，只需要使用ctrl+F4快捷键即可。</p>
<h2 id="23-批量修改">2.3 批量修改</h2>
<p>使用ctrl+w选中rabbitTemplate这个文本,然后依次使用5次alt+j快捷键，逐个选中，这样五个文本就都被选中并且高亮起来了，这个时候就可以直接批量修改了。<br>
<img src="https://haihaihai2015.github.io/post-images/1635226050410.png" alt="" loading="lazy"><br>
<img src="https://haihaihai2015.github.io/post-images/1635226058963.png" alt="" loading="lazy"></p>
<h2 id="24-symbol模糊查找只记得某几个字母">2.4 symbol，模糊查找，只记得某几个字母</h2>
<p>如果你依稀记得某个方法名字几个字母，想在IDEA里面找出来，可以怎么做呢？<br>
直接使用ctrl+shift+alt+n，使用symbol来查找即可。<br>
比如说：<br>
<img src="https://haihaihai2015.github.io/post-images/1635226243550.png" alt="" loading="lazy"><br>
你想找到checkUser方法。直接输入user即可。<br>
<img src="https://haihaihai2015.github.io/post-images/1635226255589.png" alt="" loading="lazy"><br>
如果你记得某个业务类里面有某个方法，那也可以使用首字母找到类,然后加个.，再输入方法名字也是可以的。<br>
<img src="https://haihaihai2015.github.io/post-images/1635226306018.png" alt="" loading="lazy"></p>
<h2 id="25-自动生成not-null判断语句">2.5 自动生成not null判断语句</h2>
<p>当我们使用rabbitTemplate. 后，直接输入notnull并回车，IDEA就好自动生成if判断了。<br>
<img src="https://haihaihai2015.github.io/post-images/1635226454195.png" alt="" loading="lazy"><br>
<img src="https://haihaihai2015.github.io/post-images/1635226467575.png" alt="" loading="lazy"></p>
<h2 id="26-代码调试">2.6 代码调试</h2>
<h3 id="视图模式">视图模式：</h3>
<ol>
<li>Presentation Mode - 演示模式，专门用于Code Review这种需要展示代码的场景。使用方法alt + V弹出View，然后选择Enter Presentation Mode，之后，可以在view中选择Exit Presentation Mode。但是完全没必要退出，因为当你对IDEA足够熟悉的时候，可以在演示试图中做任何事情。<br>
在演示模式中，可以使用快捷键进行操作，更加方便。</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl + E</td>
<td style="text-align:center">弹出最近使用的文件</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + N</td>
<td style="text-align:center">定位文件</td>
</tr>
<tr>
<td style="text-align:center">Ctrl + shift + N</td>
<td style="text-align:center">定位文件</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>Distraction Free Mode - 禅模式</li>
</ol>
<ul>
<li>条件断点</li>
<li>强制返回</li>
<li>在打断点的方法栈处，强制返回你想要的方法返回值给调用方。</li>
<li>模拟异常<br>
IDEA 可以在打断点的方法栈处，强制抛出异常给调用方。这个在调试源码的时候非常有用。</li>
<li>Evaluate Expression：IDEA 还可以在调试代码的时候，动态修改当前方法栈中变量的值，方便我们的调试。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一个来我网站的]]></title>
        <id>https://haihaihai2015.github.io/post/di-yi-ge-lai-wo-wang-zhan-de/</id>
        <link href="https://haihaihai2015.github.io/post/di-yi-ge-lai-wo-wang-zhan-de/">
        </link>
        <updated>2021-10-21T01:15:12.000Z</updated>
        <content type="html"><![CDATA[<p>你一定是仙女吧💑</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[@ SpringBoot整合RabbitMQ]]></title>
        <id>https://haihaihai2015.github.io/post/rabbitmq/</id>
        <link href="https://haihaihai2015.github.io/post/rabbitmq/">
        </link>
        <updated>2021-10-20T14:01:52.000Z</updated>
        <content type="html"><![CDATA[<p><strong>接到需求要将RabbitMQ与项目整合，用来异步发送消息，功能不是很重要，只是用来存储错误日志，本以为很简单的需求，结果开始了踩坑之旅</strong></p>
<h2 id="一-配置rabbitmq">一、配置RabbitMQ</h2>
<ul>
<li>项目用的是spring boot搭建，所以采用全注解的方式进行整合</li>
</ul>
<h3 id="1导入rabbit依赖">1.导入rabbit依赖</h3>
<blockquote>
<p>注意：<br>
如果依赖需要被几个子工程使用，就将依赖放入父工程，并对其进行版本约束，这里有个坑：</p>
</blockquote>
<ol>
<li>如果父工程采用的是&lt;dependencyManagement&gt;标签，则其他子工程无法自动引入依赖，需要手动添加(无需指定版本)；</li>
<li>也可以直接另加一个&lt;dependencies&gt;的标签，仅在父工程引入依赖后即可</li>
</ol>
<pre><code class="language-xml">        &lt;!-- 暂指定RabbitMQ版本--&gt;
        &lt;rabbitMq.version&gt;2.2.11.RELEASE&lt;/rabbitMq.version&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
        &lt;version&gt;${rabbitMq.version}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="2在config类配置mq参数">2.在Config类配置Mq参数</h3>
<blockquote>
<p>注意：<br>
如果项目采用集群方式搭建，要注意api调用😭<br>
如果启动后无法创建队列，可以手动去RabbitMq管理页面进行创建交换机并绑定队列；<br>
无法自动创建应该是配置问题，可以在配置文件中实例化 RabbitAdmin 解决（还没有试🖐）</p>
</blockquote>
<pre><code class="language-java">
/**
 *
 * @Description:  RabbitMQ配置类
 */
@Configuration

public  class RabbitMQConfig {

    private static final Logger log = LoggerFactory.getLogger(RabbitMQConfig.class);
//    服务地址
    @Value(&quot;${rabbitmq.addresses}&quot;)
    private String addresses;


//    虚拟主机
    @Value(&quot;${rabbitmq.virtual-host}&quot;)
    private String virtualHost;


    //    账户名
    @Value(&quot;${rabbitmq.username}&quot;)
    private String username;

//    密码
    @Value(&quot;${rabbitmq.password}&quot;)
    private String password;

//    路由键名称
    @Value(&quot;${rabbitmq.routing-key}&quot;)
    private String routingkey;

//    交换机名称
    @Value(&quot;${rabbitmq.exchange}&quot;)
    private String exchange;

//    队列名称
    @Value(&quot;${rabbitmq.queue}&quot;)
    private String queue;

//    是否重试
    @Value(&quot;${rabbitmq.enabled}&quot;)
    private String enabled;

//    最大重试次数
    @Value(&quot;${rabbitmq.max-attempts}&quot;)
    private String maxAttempts;


    /**
     * 交换机
     *
     * @return
     */
    @Bean
    public DirectExchange exchange() {
        return new DirectExchange(exchange, true, false);
    }

    /**
     * 队列
     *
     * @return
     */
    @Bean
    public Queue queue() {
        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();

        // x-message-ttl 这里声明当前队列消息存活时间
        //args.put(&quot;x-message-ttl&quot;, 6000000);
        return new Queue(queue, true, false, false, args);
    }

    /**
     * 声明 oms队列 与 开发交换机的绑定关系
     *
     * @return
     */
    @Bean
    public Binding binding() {
        return BindingBuilder.bind(queue()).to(exchange()).with(routingkey);
    }

    /**
     * 创建连接工厂
     * @return
     */
    @Bean(name = &quot;connectionFactoryMB&quot;)
    public ConnectionFactory connectionFactory() {
        CachingConnectionFactory cachingConnectionFactory = new CachingConnectionFactory();
        cachingConnectionFactory.setAddresses(addresses);
        cachingConnectionFactory.setUsername(username);
        cachingConnectionFactory.setPassword(password);
        cachingConnectionFactory.setVirtualHost(virtualHost);

        log.info(&quot;连接工厂设置完成，连接地址{}&quot;,addresses);
        log.info(&quot;连接工厂设置完成，连接用户{}&quot;,username);
        return cachingConnectionFactory;
    }


    /**
     * 实例化RabbitTemplate工具类
     * @param connectionFactory
     * @return
     */
    @Bean
    public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactoryMB) {
        RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactoryMB);
        return rabbitTemplate;
    }

    /**
     * 设置明确默认值的监听器工厂
     * @param connectionFactory
     * @return
     */
    @Bean
    public RabbitListenerContainerFactory&lt;?&gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory){
        //SimpleRabbitListenerContainerFactory发现消息中有content_type有text就会默认将其转换成string类型的
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        return factory;
    }

}

</code></pre>
<p>附上参考链接：<br>
[https://blog.csdn.net/weixin_34209406/article/details/92568996 ]<br>
[https://blog.csdn.net/weixin_43744059/article/details/106231698]<br>
[https://blog.csdn.net/qq_35387940/article/details/100514134]<br>
3. 配置生产者</p>
<ul>
<li>生产者配置相对简单，只需要将 rabbitTemplate 类注入，调用 convertAndSend 方法，参数为交<strong>换机名称</strong>、<strong>队列名称</strong>、<strong>发送内容</strong>（注意与配置一一对应）</li>
</ul>
<pre><code class="language-java">/**
 *
 * @desc:  RabbitMq生产者实现类
 */
@Component
public class FailProducerService implements FailProducer {

    private static final Logger log = LoggerFactory.getLogger(FeiHeProcessService.class);
    //    交换机名称
    @Value(&quot;${rabbitmq.exchange}&quot;)
    private String exchange;

    //    路由键名称
    @Value(&quot;${rabbitmq.routing-key}&quot;)
    private String routingKey;


    //    注入RabbitTemplate
    @Autowired
    private RabbitTemplate rabbitTemplate;


    @Override
    public void convertAndSend(FailureDto FailureDto) {


//       调用RabbitTemplate发送消息
        try {
            String json = JSONObject.toJSONString(FailureDto);
            rabbitTemplate.convertAndSend(exchange, routingKey, json);
            log.info(&quot;发送消息内容：{}&quot;,json);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

</code></pre>
<ol start="4">
<li>配置消费者</li>
</ol>
<ul>
<li>消费者则更加简单，一个注解搞定 @RabbitListener（指定的队列名）</li>
</ul>
<blockquote>
<p>注意：<br>
配置完消费后，无法消费消息的情况：首先检查队列内有无待消费消息，启动类加上 @EnableRabbit 注解就可以接到了</p>
</blockquote>
<pre><code class="language-java">/**
 *
 * @Description:  RabbitMq消费者接口实现类
 */
@Component
public class FailConsumerService {
    private static final Logger log = LoggerFactory.getLogger(FeiHeProcessService.class);
    private static final String QUEUES = &quot;fail_log_queue&quot;;

    @Autowired
    private FailureDto failureDao;

    @RabbitHandler(isDefault = true)
    @RabbitListener(queues = QUEUES)
    public void PrintLog(Message message) {

        if (message != null &amp;&amp; message.getBody() != null) {
            log.info(&quot;接收到消息为：{}&quot;, message);

//        1.解析Json
            FailureDto failureDto = null;
            try {
                failureDto = JSON.parseObject(new String(message.getBody()), FailureLogDto.class);
            } catch (Exception e) {
                e.printStackTrace();
                log.error(&quot;Json转换实体失败：&quot;, e);
            }
//        2.存库
            try {
                failureDao.insertFailLog(failureDto);
                log.info(&quot;保存成功！&quot;);
            } catch (Exception e) {
                e.printStackTrace();
                log.error(&quot;错误日志保存失败：&quot;, e);
            }
        }

    }

}
</code></pre>
]]></content>
    </entry>
</feed>